# Shared System Patterns & Standards

*Generated by Architect Mode on 2025-05-08*

*This document outlines reusable design patterns, coding standards, API conventions, and tool configurations applicable across the project.*

## 1. Coding Standards

*   **Python (Backend - FastAPI):**
    *   **Linter/Formatter:** Ruff will be used as the primary linter and formatter, configured via `pyproject.toml`. Adherence to Ruff's default ruleset is expected, with project-specific adjustments made as needed.
    *   **Style Guide:** PEP 8 is the foundational style guide.
    *   **Naming Conventions:**
        *   Modules: `lower_snake_case`
        *   Packages: `lower_snake_case`
        *   Classes: `PascalCase`
        *   Functions & Methods: `lower_snake_case`
        *   Variables: `lower_snake_case`
        *   Constants: `UPPER_SNAKE_CASE`
    *   **Type Hinting:** Comprehensive type hinting is mandatory for all new Python code to leverage FastAPI's data validation and improve code clarity.
    *   **Docstrings:** Google-style docstrings are recommended for all public modules, classes, functions, and methods.

*   **TypeScript (Frontend - Next.js/React):**
    *   **Linter:** ESLint will be configured with recommended rulesets for TypeScript, React, and Next.js.
    *   **Formatter:** Prettier will be used for consistent code formatting.
    *   **Naming Conventions:**
        *   Files: `kebab-case.ts` or `kebab-case.tsx` (components can be `PascalCase.tsx`)
        *   Interfaces & Types: `PascalCase`
        *   Classes: `PascalCase`
        *   Enums: `PascalCase` (members `UPPER_SNAKE_CASE` or `PascalCase`)
        *   Functions & Methods: `camelCase`
        *   Variables & Parameters: `camelCase`
        *   Constants: `UPPER_SNAKE_CASE`
    *   **Imports:** Organize imports, preferably with an import sorter integrated with Prettier/ESLint.

## 2. API Design Conventions (FastAPI Backend)

*   **Style:** RESTful principles will be followed for API design.
*   **Specification:** OpenAPI 3.x will be used for API documentation. FastAPI automatically generates this (accessible at `/docs` and `/redoc`). Pydantic models will define request and response schemas.
*   **Versioning:** (Not critical for MVP, but for future consideration) API versioning can be implemented via URL path (e.g., `/v1/...`).
*   **Authentication:** (MVP scope does not include user authentication, but API-to-API security might be needed for internal services or future external API exposure). If needed, token-based authentication (e.g., JWT, OAuth2 Bearer Tokens via FastAPI's security utilities) will be implemented.
*   **Data Format:** JSON will be the exclusive data format for request and response bodies.
*   **HTTP Methods:** Use standard HTTP methods appropriately:
    *   `GET`: Retrieve resources.
    *   `POST`: Create new resources.
    *   `PUT`: Update existing resources (replace entire resource).
    *   `PATCH`: Partially update existing resources.
    *   `DELETE`: Remove resources.
*   **Status Codes:** Use standard HTTP status codes:
    *   `200 OK`: General success.
    *   `201 Created`: Resource successfully created.
    *   `204 No Content`: Request successful, but no data to return (e.g., after a DELETE).
    *   `400 Bad Request`: Client-side error (e.g., invalid input, malformed request). FastAPI's Pydantic validation will typically handle this.
    *   `401 Unauthorized`: Client is not authenticated.
    *   `403 Forbidden`: Client is authenticated but does not have permission to access the resource.
    *   `404 Not Found`: Resource does not exist.
    *   `409 Conflict`: Request conflicts with the current state of the resource (e.g., duplicate entry).
    *   `422 Unprocessable Entity`: The request was well-formed but semantically incorrect (FastAPI uses this for validation errors by default).
    *   `500 Internal Server Error`: Generic server-side error.
    *   `503 Service Unavailable`: Server is temporarily unable to handle the request (e.g., maintenance, overload).
*   **Response Format (JSON):**
    *   **Successful Responses:**
        ```json
        {
          "data": { /* requested data or result of operation */ },
          "message": "Optional success message"
        }
        ```
        For list responses, `data` can be an array.
    *   **Error Responses:**
        ```json
        {
          "error": {
            "code": "ERROR_CODE_STRING", // Project-specific error code
            "message": "User-friendly error message.",
            "details": { /* Optional: specific field errors or additional info */ }
          }
        }
        ```
        FastAPI's default validation error responses will be used as a base and can be customized if needed.
*   **Filtering, Sorting, Pagination (for GET requests returning lists):**
    *   Filtering: Use query parameters (e.g., `?status=active&name=something`).
    *   Sorting: Use a `sort_by` query parameter (e.g., `?sort_by=created_at:desc`).
    *   Pagination: Use `offset` and `limit` query parameters (e.g., `?offset=0&limit=20`). Include pagination metadata in the response (e.g., `total_items`, `current_page`, `total_pages`).
*   **Idempotency:** For `PUT` and `DELETE` operations, ensure they are idempotent. `POST` operations are typically not idempotent.

## 3. Reusable Architectural Patterns

*   **Repository Pattern (Backend):** Consider using the repository pattern to abstract database interactions from the service layer. This can improve testability and maintainability by decoupling business logic from data access specifics.
*   **Service Layer (Backend):** Implement a service layer to encapsulate business logic, orchestrating calls to repositories and other services.
*   **Dependency Injection (Backend):** FastAPI has built-in support for dependency injection, which should be leveraged extensively for managing dependencies like database sessions, service instances, and configurations. This enhances testability and modularity.

## 4. Common Utility Libraries/Functions

*   (To be populated as the project develops. This section will list or link to shared utility modules for tasks like date/time manipulation, string formatting, common data transformations, etc.)