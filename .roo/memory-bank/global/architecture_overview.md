# Architecture Overview

*Generated by Architect Mode on 2025-05-08*

## 1. System Context Diagram

```mermaid
graph TD
    User[User] -- HTTPS --> NextApp[Next.js Web App (UI + BFF)]
    NextApp -- API Calls (REST/GraphQL) --> FastAPIBackend[Python FastAPI Backend (Monolith)]
    FastAPIBackend -- SQL --> DB[(PostgreSQL Database)]
    FastAPIBackend -- LLM API Calls --> LLMProvider[LLM Service Provider API]
    FastAPIBackend -- Exchange API Calls --> TradingExchange[Trading Exchange/Broker API]
    NextApp -- WebSocket --> FastAPIBackend

    subgraph "Frontend Tier (Next.js)"
        direction LR
        ReactUI[React 19 UI Components (Magic UI)]
        NextAPIRoutes[Next.js API Routes (BFF)]
        StateManagement[Zustand (State Management)]
        DataFetching[SWR (Data Fetching)]
        ReactUI --> NextAPIRoutes
        ReactUI --> StateManagement
        ReactUI --> DataFetching
        NextAPIRoutes --> FastAPIBackend
    end

    subgraph "Backend Tier (FastAPI Monolith)"
        direction LR
        APILayer[API Endpoints (FastAPI)]
        AgentCore[Agent Core Logic]
        ToolExecutor[Tool Executor]
        DBAccess[Database Access (SQLAlchemy ORM)]
        WebSocketHandler[WebSocket Handler]
        APILayer --> AgentCore
        AgentCore --> ToolExecutor
        AgentCore --> DBAccess
        ToolExecutor --> TradingExchange
        ToolExecutor --> LLMProvider
        APILayer --> WebSocketHandler
        DBAccess --> DB
    end
```

**Description:**

The system follows a client-server architecture.
*   **User:** Interacts with the system via the Next.js web application.
*   **Next.js Web App:** Serves as the frontend UI (built with React 19 and Magic UI) and a Backend-for-Frontend (BFF) using Next.js API Routes. It handles user interactions, renders the UI, manages client-side state (Zustand), fetches data (SWR), and communicates with the main backend. Real-time updates are received via WebSockets.
*   **Python FastAPI Backend:** A monolithic backend service responsible for core business logic, including the AI Agent's operations, tool execution, interaction with third-party LLM and trading exchange APIs, and database operations via SQLAlchemy. It also hosts the WebSocket server for real-time communication with the frontend.
*   **PostgreSQL Database:** The primary data store for user configurations, trading strategies, trade history, Agent logs, and other persistent data.
*   **LLM Service Provider API:** External API for large language model capabilities.
*   **Trading Exchange/Broker API:** External API for market data and trade execution.

## 2. Key Technology Stack

*   **Frontend:**
    *   Language: **TypeScript**
    *   Framework/Library: **Next.js 14+ (App Router)**, **React 19**
    *   UI Components: **Magic UI**
    *   State Management: **Zustand**
    *   Data Fetching: **SWR**
    *   Package Manager: **Pnpm**
*   **Backend:**
    *   Language: **Python 3.11+**
    *   Framework: **FastAPI**
    *   ORM: **SQLAlchemy 2.x**
    *   Async Support: Native FastAPI (ASGI with Uvicorn/Hypercorn)
    *   Package Management/Runner: **uv**
    *   Linter/Formatter: **Ruff**
    *   WebSocket: FastAPI native support
*   **Database:**
    *   **PostgreSQL 15+**
*   **Deployment & Infrastructure:**
    *   Containerization: **Docker**
    *   Cloud Provider(s): To be decided (design aims for cloud-agnostic deployment where possible, e.g., AWS, Google Cloud, Azure).
*   **Other Key Libraries/Tools:**
    *   TradingView Lightweight Charts (for embedding charts in the frontend).

## 3. Architectural Principles

*   **Monolithic Backend for MVP:** Start with a well-structured monolith for the backend to simplify development and deployment for the MVP. Future iterations may consider evolving to microservices if complexity and scalability needs dictate.
*   **Modularity:** Design components with clear responsibilities and well-defined interfaces, even within the monolith. This facilitates easier maintenance, testing, and potential future separation.
*   **Scalability:** While starting as a monolith, design services to be stateless where possible to allow for horizontal scaling. Database scalability will be managed via PostgreSQL's capabilities and appropriate schema design.
*   **Maintainability:** Emphasize clean code, comprehensive documentation (including this document and others in the Memory Bank), consistent coding standards enforced by Ruff, and thorough testing.
*   **Security:** Implement security best practices at all layers:
    *   Secure API key management (encryption at rest, careful handling in transit).
    *   Input validation for all API endpoints.
    *   Authentication and authorization mechanisms (though user auth is out of MVP, API-to-API security is relevant).
    *   Protection against common web vulnerabilities.
*   **Simplicity for MVP (Keep It Simple, Stupid - KISS):** Prioritize delivering core MVP functionality. Avoid premature optimization or over-engineering. Technology choices should favor ease of use and rapid development for the initial phase.
*   **Testability:** Design components and services to be easily testable, with a focus on unit, integration, and end-to-end tests.
*   **Asynchronous Operations:** Leverage Python's asyncio and FastAPI's native async capabilities for I/O-bound tasks (interacting with external APIs, database operations) to ensure non-blocking performance.

## 4. Major Components & Interactions

*   **A. Frontend Application (Next.js):**
    *   **UI Layer (React Components):** Renders the user interface, including dashboards, charts (TradingView), configuration forms, and the Agent interaction panel. Uses Magic UI for styling and components.
    *   **State Management (Zustand):** Manages global client-side state such as user preferences, UI state, and cached data from the backend.
    *   **Data Fetching (SWR):** Handles client-side data fetching from Next.js API Routes or directly from the FastAPI backend, providing caching and revalidation.
    *   **API Routes (BFF):** Acts as an intermediary between the client-side UI and the main FastAPI backend. Can be used for aggregating data, request/response transformation, or handling frontend-specific logic.
    *   **WebSocket Client:** Establishes and maintains a WebSocket connection with the FastAPI backend to receive real-time updates (e.g., Agent's thinking log, trade notifications, position updates).
    *   **Interaction Flow:**
        1.  User interacts with UI.
        2.  UI components trigger actions that may involve state changes (Zustand), data fetching (SWR via API Routes/FastAPI), or sending commands to the backend.
        3.  Real-time updates from the backend are pushed via WebSockets and reflected in the UI.

*   **B. Backend Application (FastAPI Monolith):**
    *   **API Endpoints:** Exposes RESTful APIs for the frontend (and potentially other future clients) to interact with. Handles HTTP requests, performs input validation (Pydantic), and orchestrates backend logic.
    *   **Agent Core Logic:** The heart of the system. Implements the Agentic Loop, manages Agent instances, constructs prompts for LLMs, parses LLM responses, and coordinates tool execution.
    *   **Tool Executor:** A module responsible for executing the various tools defined for the Agent (e.g., fetching market data, calculating indicators, placing orders). It interacts with external exchange APIs and LLM provider APIs.
    *   **Database Access Layer (SQLAlchemy ORM):** Manages all interactions with the PostgreSQL database. Defines data models and handles CRUD operations, transaction management.
    *   **WebSocket Handler:** Manages WebSocket connections from clients, broadcasts real-time messages (e.g., Agent logs, trade updates) to connected clients.
    *   **Configuration Management:** Loads and provides access to system configurations, including API keys for external services (securely).
    *   **Interaction Flow:**
        1.  Receives requests from the Frontend (API Routes or direct SWR calls).
        2.  API Endpoints validate requests and delegate to appropriate services/modules (e.g., Agent Core).
        3.  Agent Core processes requests, interacts with LLM, uses Tool Executor, and accesses/updates data via DBAccess.
        4.  Tool Executor calls external APIs (Exchanges, LLMs).
        5.  WebSocket Handler pushes real-time updates to subscribed frontend clients.

*   **C. Database (PostgreSQL):**
    *   Stores all persistent data:
        *   User and Agent configurations (API keys, strategy settings).
        *   Trading strategies defined by users.
        *   Historical trade data and order details.
        *   Agent activity logs and decision-making processes.
        *   (Future) User accounts if authentication is added.
    *   Accessed by the FastAPI backend via the SQLAlchemy ORM.

*   **D. External Services:**
    *   **LLM Provider APIs:** Accessed by the Tool Executor in the backend to leverage language model capabilities for Agent decision-making and natural language understanding.
    *   **Trading Exchange/Broker APIs:** Accessed by the Tool Executor for live market data, placing/managing orders, and retrieving account information.
    *   **TradingView Library:** Integrated into the frontend for displaying market charts.

This architecture aims to provide a solid foundation for the MVP of Vibetrade, balancing rapid development with considerations for future growth and maintainability.