# Universal Commit Protocol
# This rule defines the mandatory protocol ALL modes must follow when committing
# changes to a version control repository (Git). It ensures consistency,
# verification of changes, and adherence to commit message standards.
# This protocol is considered a sub-routine that a mode executes when it needs to commit.
# Upon successful completion of this protocol, the mode should have the commit hash.

version_control_procedures:
  standard_commit_protocol:
    trigger: "When a mode (e.g., Code-Frontend, Code-Backend, Doc-Writer, or others modifying version-controlled files) has completed a logical unit of work involving file modifications and determines it is appropriate to commit these changes."
    priority: 800 # High priority when a commit is decided.
    action: |
      <thinking>
      **[Standard Commit Protocol Activated - Initiating Commit Sequence]**
      I have been activated to perform a commit. I expect the following context to be available from the mode that activated me or from my current operational context:
      - `{git current branch}`: The Git branch I am currently working on.
      - `{context.changed_files_for_commit}`: A list of specific file paths (relative to `context.git_command_cwd`) to be committed.
      - `{context.commit_message_type}`: The Conventional Commit type (e.g., "feat", "fix").
      - `{context.commit_message_scope}` (optional): The scope for the Conventional Commit.
      - `{context.commit_message_description}`: A concise description of the changes.
      - `{context.associated_task_id_for_commit}` (optional but highly recommended): The task ID(s) related to this commit.
      - `{context.git_command_cwd}`: The current working directory for Git commands.

      My process:
      1.  **Stage Changes:** Use `git add` with the provided `{context.changed_files_for_commit}`.
      2.  **Review Staged Changes (for activating mode's verification):** Use `git diff --staged`. The activating mode is responsible for verifying this diff.
      3.  **Construct Full Commit Message:** Combine type, scope, description, and task ID into a Conventional Commits formatted message, all lowercase.
      4.  **Execute Commit:** Use `git commit -m "Full Message"`.
      5.  **Retrieve Commit Hash:** Use `git log -1 --pretty=format:"%H"`.
      6.  **Protocol Completion:** The commit hash is now available for the activating mode.
      </thinking>

      <thinking>
      **Step 1: Stage Changed Files.**
      Using file list: `{context.changed_files_for_commit}`.
      The file paths in this list must be space-separated if multiple for the command line.
      The activating mode should ensure this formatting if passing a pre-formatted string, or I will join the list with spaces.
      Let's assume `{context.changed_files_for_commit_string}` is the space-separated string of files.
      </thinking>
      <execute_command>
      <command>git add {context.changed_files_for_commit_string}</command>
      <cwd>{context.git_command_cwd}</cwd>
      </execute_command>
      <!-- Wait for confirmation -->
      <thinking>
      **Step 2: Review Staged Changes (Output for Verification by Activating Mode).**
      </thinking>
      <execute_command>
      <command>git diff --staged</command>
      <cwd>{context.git_command_cwd}</cwd>
      </execute_command>
      <!-- Wait for diff output. Activating mode handles verification of this output. -->
      <thinking>
      **Step 3: Construct Full Commit Message.**
      I will use the provided context variables:
      `type: {context.commit_message_type}`
      `scope: {context.commit_message_scope}` (if provided)
      `description: {context.commit_message_description}`
      `task_id: {context.associated_task_id_for_commit}` (if provided)
      I will construct the `{constructed_commit_message}` string according to Conventional Commits format, ensuring it's all lowercase and includes the task ID in parentheses at the end of the description if provided.
      For example: `{context.commit_message_type}({context.commit_message_scope}): {context.commit_message_description} ({context.associated_task_id_for_commit})` or similar variations based on provided context.
      </thinking>
      <thinking>
      **Step 4: Execute Commit.**
      Committing with message: `{constructed_commit_message}`.
      </thinking>
      <execute_command>
      <command>git commit -m "{constructed_commit_message}"</command>
      <cwd>{context.git_command_cwd}</cwd>
      </execute_command>
      <!-- Wait for confirmation of commit success. -->
      <thinking>
      Commit successful.
      **Step 5: Retrieve Commit Hash.**
      </thinking>
      <execute_command>
      <command>git log -1 --pretty=format:"%H"</command>
      <cwd>{context.git_command_cwd}</cwd>
      </execute_command>
      <!-- Wait for output. Assume output is {actual_commit_hash}. -->
      <thinking>
      **Step 6: Protocol Completion.**
      Commit hash `{actual_commit_hash}` obtained.
      This standard commit protocol is now complete for this unit of work.
      The activating mode now has this commit hash (`{actual_commit_hash}`) to use in its reporting or further actions.
      </thinking>