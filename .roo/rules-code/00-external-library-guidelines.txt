mcp_integration_rules:
  documentation_lookup:
    trigger: "When the user asks for information about a library, its best practices, or to review code against its documentation (e.g., 'check FastAPI code for best practices', 'how to use X feature in Y library')."
    action: |
      <thinking>
      The user is asking for library-specific information or a code review based on library documentation. I need to use the context7 MCP server to get this information.
      Plan:
      1. Identify the library name from the user's request.
      2. Use `context7`'s `resolve-library-id` tool to get the Context7-compatible library ID.
      3. Explain the choice of library ID if multiple matches are found.
      4. Use `context7`'s `get-library-docs` tool with the obtained ID and relevant topic (if specified or inferable) to fetch the documentation.
      5. Use the fetched documentation to answer the user's question or perform the code review.
      </thinking>
      Example tool use for resolve-library-id:
      <use_mcp_tool>
        <server_name>context7</server_name>
        <tool_name>resolve-library-id</tool_name>
        <arguments>
          {
            "libraryName": "TheLibraryName"
          }
        </arguments>
      </use_mcp_tool>
      Example tool use for get-library-docs:
      <use_mcp_tool>
        <server_name>context7</server_name>
        <tool_name>get-library-docs</tool_name>
        <arguments>
          {
            "context7CompatibleLibraryID": "c7-library-id",
            "topic": "OptionalTopic"
          }
        </arguments>
      </use_mcp_tool>

  dependency_version_check:
    trigger: "When adding new dependencies, updating existing ones, or when the user explicitly asks to check/update dependency versions (e.g., 'add library X', 'update all packages', 'are my Python dependencies up to date?')."
    action: |
      <thinking>
      The user's request involves managing project dependencies or ensuring they are up-to-date. I need to use the package-version MCP server.
      Plan:
      1. Identify the relevant package manager or dependency file (e.g., package.json, requirements.txt, pyproject.toml, go.mod, pom.xml, build.gradle).
      2. Read the content of the dependency file if not already available.
      3. Based on the file type, select the appropriate tool from the `package-version` MCP server (e.g., `check_npm_versions`, `check_python_versions`, `check_pyproject_versions`, `check_go_versions`, `check_maven_versions`, `check_gradle_versions`).
      4. Call the selected tool with the necessary arguments (e.g., the dependencies object).
      5. Analyze the results to identify outdated packages.
      6. If updates are needed and approved by the user, apply the changes to the dependency file and inform the user about the updates.
      </thinking>
      Example tool use (for npm, assuming package.json content is known):
      <use_mcp_tool>
        <server_name>package-version</server_name>
        <tool_name>check_npm_versions</tool_name>
        <arguments>
          {
            "dependencies": { "express": "^4.17.1", "lodash": "~4.17.20" }
          }
        </arguments>
      </use_mcp_tool>
      Example tool use (for Python requirements.txt, assuming its content is known):
      <use_mcp_tool>
        <server_name>package-version</server_name>
        <tool_name>check_python_versions</tool_name>
        <arguments>
          {
            "requirements": ["requests==2.25.1", "numpy>=1.20.0"]
          }
        </arguments>
      </use_mcp_tool>
