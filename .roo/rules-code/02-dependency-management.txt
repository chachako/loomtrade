mcp_integration_rules:
  documentation_lookup:
    trigger: "When the user asks for information about a library, its best practices, or to review code against its documentation (e.g., 'check FastAPI code for best practices', 'how to use X feature in Y library')."
    priority: 499
    action: |
      <thinking>
      The user is asking for library-specific information or a code review based on library documentation. I need to use the context7 MCP server to get this information.
      Plan:
      1. Identify the library name from the user's request.
      2. Use `context7`'s `resolve-library-id` tool to get the Context7-compatible library ID.
      3. Explain the choice of library ID if multiple matches are found.
      4. Use `context7`'s `get-library-docs` tool with the obtained ID and relevant topic (if specified or inferable) to fetch the documentation.
      5. Use the fetched documentation to answer the user's question or perform the code review.
      </thinking>
      Example tool use for resolve-library-id:
      <use_mcp_tool>
        <server_name>context7</server_name>
        <tool_name>resolve-library-id</tool_name>
        <arguments>
          {
            "libraryName": "TheLibraryName"
          }
        </arguments>
      </use_mcp_tool>
      Example tool use for get-library-docs:
      <use_mcp_tool>
        <server_name>context7</server_name>
        <tool_name>get-library-docs</tool_name>
        <arguments>
          {
            "context7CompatibleLibraryID": "c7-library-id",
            "topic": "OptionalTopic"
          }
        </arguments>
      </use_mcp_tool>

  dependency_version_check:
    trigger: "When adding new dependencies, updating existing ones, or when the user explicitly asks to check/update dependency versions (e.g., 'add library X', 'update all packages', 'are my Python dependencies up to date?')."
    priority: 500
    action: |
      <thinking>
      The user's request involves managing project dependencies or ensuring they are up-to-date. I need to use the package-version MCP server.
      Plan:
      1. Identify the relevant package manager or dependency file (e.g., package.json, requirements.txt, pyproject.toml, go.mod, pom.xml, build.gradle).
      2. Read the content of the dependency file if not already available.
      3. Based on the file type, select the appropriate tool from the `package-version` MCP server (e.g., `check_npm_versions`, `check_python_versions`, `check_pyproject_versions`, `check_go_versions`, `check_maven_versions`, `check_gradle_versions`).
      4. Call the selected tool with the necessary arguments (e.g., the dependencies object).
      5. Analyze the results to identify outdated packages.
      6. If updates are needed and approved by the user, apply the changes to the dependency file and inform the user about the updates.
      </thinking>
      Example tool use (for npm, assuming package.json content is known):
      <use_mcp_tool>
        <server_name>package-version</server_name>
        <tool_name>check_npm_versions</tool_name>
        <arguments>
          {
            "dependencies": { "express": "^4.17.1", "lodash": "~4.17.20" }
          }
        </arguments>
      </use_mcp_tool>
      Example tool use (for Python requirements.txt, assuming its content is known):
      <use_mcp_tool>
        <server_name>package-version</server_name>
        <tool_name>check_python_versions</tool_name>
        <arguments>
          {
            "requirements": ["requests==2.25.1", "numpy>=1.20.0"]
          }
        </arguments>
      </use_mcp_tool>

dependency_management_automation:
  auto_install_dependencies:
    trigger: "When a package.json file is created or its 'dependencies' or 'devDependencies' sections are modified, or when other common dependency files like requirements.txt (Python), pyproject.toml (Python), go.mod (Go) are created or changed."
    priority: 100
    action: |
      <thinking>
      A dependency file (e.g., package.json, requirements.txt) has been created or modified.
      I need to automatically run the appropriate installation command using the project's preferred package manager.

      Plan:
      1. Identify the directory of the changed dependency file (e.g., `frontend/` if `frontend/package.json` changed).
      2. Determine the package manager and command:
         - If `package.json` changed in a Node.js project (like `frontend/`), use `pnpm install` (based on recorded user preference).
         - If `requirements.txt` or `pyproject.toml` changed in a Python project (like `backend/`), use `pip install -r requirements.txt` (or potentially `poetry install` if pyproject.toml indicates Poetry usage - need to confirm project setup or ask user if ambiguous).
         - If `go.mod` changed, use `go mod tidy`.
         - (Extend with other common dependency files and managers as needed).
      3. Construct the `execute_command` tool usage with the correct command and `cwd`.
      4. Inform the user in the subsequent `attempt_completion` (if applicable) or in the next response that the installation command was automatically executed.
      </thinking>
      Example for frontend/package.json change (assuming it's the trigger):
      <execute_command>
      <command>pnpm install</command>
      <cwd>frontend</cwd>
      </execute_command>
      <thinking>
      After this, I will proceed with the original task or provide a completion message, noting that dependencies were installed.
      </thinking>