sub_task_delegation_and_tracking:
  delegate_sub_task:
    trigger: "After feature {context.feature_id}'s `progress.yaml` has been populated with defined sub-tasks (status 'backlog' or 'defined') and Feature-Lead decides to initiate work on a specific sub-task, which will be developed directly on the `main` branch."
    priority: 850
    action: |
      <thinking>
      **[Delegate Sub-Task - Feature Lead]**
      My status is `[FEATURE_LEAD: PREPARING_SUB_TASK_DELEGATION]`. Feature ID: `{context.feature_id}`.
      I need to delegate a sub-task for feature '{context.feature_name}' to be worked on directly on the `main` branch.
      1.  **Identify Sub-Task:** Read `features/{context.feature_id}/progress.yaml`. Select task `{var_task_id_to_delegate}` (name: `{var_task_name}`, assignee: `{var_assignee_slug}`, description link: `{var_desc_link}`).
      2.  **Update `progress.yaml`:** Mark task `{var_task_id_to_delegate}` as 'delegated'.
      3.  **Formulate `new_task` Message for `{var_assignee_slug}`:**
          This message must provide:
          - `task_id` (this is `{var_task_id_to_delegate}`)
          - `task_name` (this is `{var_task_name}`)
          - `feature_id` (this is `{context.feature_id}`)
          - `feature_name` (this is `{context.feature_name}`)
          - `feature_branch`: "main" (explicitly state work is on main)
          - `detailed_task_description`: Specific instructions, using `{var_desc_link}`.
          - `feature_context_md_path`: Path to `./.roo/memory-bank/features/{context.feature_id}/context.md`
          - `feature_design_notes_md_path`: Path to `./.roo/memory-bank/features/{context.feature_id}/design_notes.md`
          - `feature_decisions_md_path`: Path to `./.roo/memory-bank/features/{context.feature_id}/decisions.md`
          - `global_shared_patterns_path`: Path to `./.roo/memory-bank/global/shared_system_patterns.md`
          - `global_architecture_path`: Path to `./.roo/memory-bank/global/architecture_overview.md`
          - `deliverables_expected`: List of expected outputs.
          - `reporting_instructions`: How to report completion.
          - `version_control_instructions`: Specific instructions for working on `main` (from `04-version-control-main-branch-guidance.txt`).
      4.  **Delegate using `new_task`.**
      My status after delegation will be `[FEATURE_LEAD: AWAITING_SUB_TASK_COMPLETION ({var_task_id_to_delegate})]`.
      </thinking>

      <!-- Example: Delegating backend API design task {context.feature_id}-api-001 to be worked on main -->
      <thinking>
      Let `{var_task_id_to_delegate}` = `{context.feature_id}-api-001`.
      Let `{var_task_name}` = "Design product creation API endpoint".
      Let `{var_assignee_slug}` = `code-backend`.
      Let `{var_desc_for_task}` = "Design the API endpoint contract (request/response schema, HTTP methods, status codes) for creating a new product. Ensure the design aligns with our global API design guidelines and specific requirements for this feature. Key details can be found in `context.md` (section 'Product Creation API Specs') and `design_notes.md` (section 'API Registration Endpoint'). All work will be on the `main` branch."
      Let `{var_deliverables}` = ["A well-defined API contract (e.g., OpenAPI snippet or clear Markdown description).", "Document this design by creating/updating a section in `./.roo/memory-bank/features/{context.feature_id}/design_notes.md`."]
      Let `{var_vc_instructions}` = "All work MUST be done directly on the `main` branch. Before starting, ensure your local `main` is up-to-date (`git checkout main && git pull origin main`). Follow Universal Commit Protocol, including task ID `({context.feature_id}/{var_task_id_to_delegate})`. Push changes to `origin main` upon completion."

      **Step 1: Update Sub-Task Status in `progress.yaml` (Before Delegation).**
      </thinking>
      <read_file><path>./.roo/memory-bank/features/{context.feature_id}/progress.yaml</path></read_file>
      <!-- Wait -->
      <thinking>
      Updating task `{context.feature_id}-api-001` status to 'delegated' in `progress.yaml`.
      </thinking>
      <write_to_file>
        <path>./.roo/memory-bank/features/{context.feature_id}/progress.yaml</path>
        <content><!-- YAML content with task {context.feature_id}-api-001 status updated to 'delegated' --></content>
        <line_count>...</line_count>
      </write_to_file>
      <!-- Wait -->
      <thinking>
      Status updated. Now, prepare and send `new_task` to `{var_assignee_slug}`.
      My status after sending `new_task` will be `[FEATURE_LEAD: AWAITING_SUB_TASK_COMPLETION ({context.feature_id}-api-001)]`.
      </thinking>

      **Step 2: Formulate Message and Delegate the Sub-Task.**
      "Delegating sub-task '{var_task_name}' to `{var_assignee_slug}` (on `main` branch)."
      <new_task>
        <mode>{var_assignee_slug}</mode>
        <message>
        # YAML-like structure for Sub-Task Assignment
        task_id: "{context.feature_id}-api-001"
        task_name: "Design product creation API endpoint"
        feature_id: "{context.feature_id}"
        feature_name: "{context.feature_name}"
        feature_branch: "main" # Explicitly main branch

        detailed_task_description: |
          Design the API endpoint contract (request/response schema, HTTP methods, status codes) for creating a new product.
          Ensure the design aligns with our global API design guidelines and specific requirements for this feature.
          Key details can be found in `context.md` (section 'Product Creation API Specs') and `design_notes.md` (section 'API Registration Endpoint').

        version_control_instructions: |
          All work MUST be done directly on the `main` branch.
          Before starting work, ensure your local `main` branch is up-to-date with the remote `origin/main` by running `git checkout main` and then `git pull origin main`.
          Follow the Universal Commit Protocol (`.roo/rules/01-universal-commit-protocol.txt`) for all commits. This protocol requires atomic commits with Conventional Commit formatted messages (all lowercase), including this task ID `({context.feature_id}/{context.feature_id}-api-001)`.
          Ensure all unit tests pass before committing.
          Push your changes on `main` to `origin/main` frequently, and especially before signaling task completion.

        deliverables_expected:
          - "A well-defined API contract (e.g., OpenAPI snippet or clear Markdown description)."
          - "Document this design by creating/updating a section in `./.roo/memory-bank/features/{context.feature_id}/design_notes.md`."

        # Context File Paths (relative to .roo/memory-bank/)
        feature_context_md_path: "features/{context.feature_id}/context.md"
        feature_design_notes_md_path: "features/{context.feature_id}/design_notes.md"
        feature_decisions_md_path: "features/{context.feature_id}/decisions.md"
        global_shared_patterns_path: "global/shared_system_patterns.md"
        global_architecture_path: "global/architecture_overview.md"

        reporting_instructions: "Upon completion, use `attempt_completion` with a summary of the designed API contract, a reference to where it's documented, and the commit hash for changes made on `main`."
        </message>
      </new_task>

  track_sub_task_completion:
    trigger: "When Feature-Lead receives an `attempt_completion` message from a sub-task mode (e.g., `code-backend`, `code-frontend`, `qa-tester`, `code-reviewer`) for a sub-task related to feature {context.feature_id}."
    priority: 860
    action: |
      <thinking>
      **[Track Sub-Task Completion - Feature Lead]**
      My status is `[FEATURE_LEAD: PROCESSING_SUB_TASK_RESULT]`. Feature ID: `{context.feature_id}`.
      I've received a completion signal for sub-task `{context.completed_task_id}` from mode `{context.reporting_mode_slug}`.
      The `attempt_completion` result from the sub-task mode should be a structured message or parsable text. I expect it to contain at least:
      - `task_id_completed`
      - `status_of_completion` (e.g., 'success', 'failure_with_blocker', 'needs_clarification')
      - `summary_of_work_done`
      - `outputs_or_artifacts_paths` (e.g., commit hashes on `main`, path to new/updated docs)
      - `new_issues_or_blockers_encountered` (if any)

      My process:
      1.  **Parse the sub-task's result.** (Extract the above fields).
      2.  **Update `features/{context.feature_id}/progress.yaml`:**
          *   Set status of `{context.completed_task_id}`.
          *   Log commit hashes (on `main`) from `outputs_or_artifacts_paths`.
      3.  **Log significant events/issues from `new_issues_or_blockers_encountered` into `features/{context.feature_id}/active_log.md`.**
      4.  **Decision Point:** Based on `status_of_completion` and feature progress, decide next steps.
      </thinking>

      <thinking>
      Received completion for task `{context.completed_task_id}`.
      Parsing the result from `{context.reporting_mode_slug}`...
      Assume result: `task_id_completed: "{context.completed_task_id}", status_of_completion: "success", summary_of_work_done: "API design complete.", outputs_or_artifacts_paths: ["Commit hash: {actual_commit_hash_on_main}", "./.roo/memory-bank/features/{context.feature_id}/design_notes.md#product-creation-api"], new_issues_or_blockers_encountered: "None"`.

      I will update `features/{context.feature_id}/progress.yaml`.
      </thinking>
      <read_file><path>./.roo/memory-bank/features/{context.feature_id}/progress.yaml</path></read_file>
      <!-- Wait -->
      <thinking>
      Updating task `{context.completed_task_id}` status to 'completed' and logging commit hash in `progress.yaml`.
      </thinking>
      <write_to_file>
        <path>./.roo/memory-bank/features/{context.feature_id}/progress.yaml</path>
        <content><!-- Full updated content of progress.yaml --></content>
        <line_count>...</line_count>
      </write_to_file>
      <!-- Wait -->
      <thinking>
      Sub-task `{context.completed_task_id}` is marked complete.
      Next, I'll check `progress.yaml` for dependent tasks.
      If ready, I will trigger `delegate_sub_task` logic for it.
      </thinking>
      <attempt_completion>
        <result>
        Sub-task '{context.completed_task_id}' for feature '{context.feature_name}' has been processed as completed. Changes are on the `main` branch.
        Preparing to delegate next sub-task if applicable.
        </result>
      </attempt_completion>
      My status becomes `[FEATURE_LEAD: ACTIVE]`. Feature ID: `{context.feature_id}`.

  monitoring_sub_tasks:
    _comment: "Proactive sub-task monitoring can be added later."
    action: |
      <thinking>
      If a sub-task for feature {context.feature_id} is stalled:
      1.  Log internal note in `active_log.md`.
      2.  Prepare `new_task` for the assignee:
          `task_type: "status_inquiry"`
          `original_task_id: "{var_stalled_task_id}"`
          `feature_id: "{context.feature_id}"`
          `query: "Status update for task '{var_stalled_task_name}'? All work is on main branch."`
      3.  Send `new_task`. My status becomes `[FEATURE_LEAD: AWAITING_STATUS_INQUIRY_RESPONSE ({var_stalled_task_id})]`.
      </thinking>